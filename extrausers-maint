#! /usr/bin/env python3
from os.path import join, exists
import os


def load_db(args):
    import yaml
    with open(args.db, "r") as dbf:
        yaml_text = dbf.read()

    return yaml.load(yaml_text)


def save_db(args, db):
    import yaml
    with open(args.db, "w") as dbf:
        dbf.write(yaml.dump(db))


def update(args):
    db = load_db(args)

    home_root = db["home_root"]
    extrausers_root = db["extrausers_root"]
    default_shell = db.get("default_shell")

    group_members = {}
    gids = {}

    passwd_lines = []
    shadow_lines = []

    for user, udata in db["users"].items():
        home_dir = join(home_root, user)
        uid = udata["uid"]
        gid = udata.get("gid", uid)

        passwd_lines.append(":".join([
                user,
                "x",
                str(uid),
                str(gid),
                udata["name"]+",,,",
                home_dir,
                udata.get("shell", default_shell)]))

        shadow_lines.append(":".join([
            user,
            udata["crypted_password"],
            "16289",
            "0",
            "99999",
            "7",
            "",
            "",
            ""]))

        for grp in udata.get("groups", []):
            group_members[grp] = group_members.get(grp, []) + [user]

        gids[user] = gid

        def make_and_own(d):
            if not exists(d):
                os.makedirs(d)
                if not args.no_chown:
                    os.chown(d, uid, gid)

        ssh_dir = join(home_dir, ".ssh")

        make_and_own(home_dir)
        make_and_own(ssh_dir)

        keys_file = join(ssh_dir, "authorized_keys")

        with open(keys_file, "w") as keysf:
            keysf.write("# automatically generated by extrausers-maint\n")
            keysf.write("# WARNING! Do not edit--file will be overwritten.\n\n")
            for l in udata.get("ssh_keys", []):
                keysf.write(l.strip() + "\n")

        if not args.no_chown:
            os.chown(keys_file, uid, gid)

    for grp, gdata in db["groups"].items():
        gids[grp] = gdata["gid"]

    group_lines = []

    for grp in gids:
        members = group_members.get(grp, [])
        gid = gids[grp]

        group_lines.append(":".join([
            grp,
            "x",
            str(gid),
            ",".join(members)]))

    with open(join(extrausers_root, "passwd"), "w") as outf:
        outf.write("\n".join(passwd_lines))

    shadow_file = join(extrausers_root, "shadow")
    with open(shadow_file, "w") as outf:
        outf.write("\n".join(shadow_lines))
    os.chmod(0o600, shadow_file)

    with open(join(extrausers_root, "group"), "w") as outf:
        outf.write("\n".join(group_lines))


def change_password(args):
    from crypt import crypt
    from base64 import b64encode
    salt = b64encode(os.urandom(16))
    import getpass
    pw = getpass.getpass()

    crypted_password = crypt(pw, "$6$%s$" % salt)

    db = load_db(args)
    db["users"][args.user]["crypted_password"] = crypted_password
    save_db(args, db)


def main():
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--db", metavar="FILE", default="userdb.yml")
    subp = parser.add_subparsers()

    parser_update = subp.add_parser("update")
    parser_update.add_argument("--no-chown", action="store_true")
    parser_update.set_defaults(func=update)

    parser_passwd = subp.add_parser("passwd")
    parser_passwd.add_argument("user")
    parser_passwd.set_defaults(func=change_password)

    args = parser.parse_args()
    args.func(args)

if __name__ == "__main__":
    main()

# vim: foldmethod=marker
