#!/usr/bin/env -S uv run --script
#
# /// script
# dependencies = [
#   "pydantic",
#   "pyyaml",
#   "typing-extensions>=4.0",
# ]
# ///

# pyright: reportExplicitAny=none, reportAny=none, reportUnusedCallResult=none

import os
import socket
import sys
from datetime import date
from os.path import exists, join
from typing import Annotated, Any

from pydantic import BaseModel, Field, StringConstraints, model_validator
from typing_extensions import Self


Username = Annotated[
    str, StringConstraints(pattern=r"^[-_a-z0-9]+$", min_length=3)]
Groupname = Annotated[
    str, StringConstraints(pattern=r"^[-_a-z0-9]+$", min_length=3)]
SSHKey = Annotated[
    str, StringConstraints(pattern=r"ssh-.*")]


class Lease(BaseModel):
    expires: date | None
    justification: str


class User(BaseModel):
    disabled: bool = False
    name: str
    email: str
    uid: int
    crypted_password: str | None = None
    ssh_keys: list[SSHKey] = Field(default_factory=list)
    gid: int
    shell: str | None = None
    remarks: str | None = None
    leases: list[Lease]
    groups: list[Groupname] = Field(default_factory=list)
    allowed_access_to_hosts: list[str] = Field(default_factory=list)

    @model_validator(mode="before")
    @classmethod
    def populate_leases(cls, data: Any) -> Any:
        if isinstance(data, dict):
            if "leases" not in data or data["leases"] is None:
                if "remarks" not in data or not data["remarks"]:
                    raise ValueError(
                            "remarks needed to generate lease, must be present")
                data["leases"] = [{
                    "expires": None,
                    "justification": data.get("remarks", "unspecified?")
                }]

        return data

    @model_validator(mode="before")
    @classmethod
    def set_default_gid(cls, data: Any) -> Any:
        if isinstance(data, dict):
            if "gid" not in data and "uid" in data:
                data["gid"] = data["uid"]

        return data

    def is_active(self):
        if self.disabled:
            return False

        result = False

        import datetime
        today = datetime.date.today()

        for lease in self.leases:
            if lease.expires is None or today <= lease.expires:
                result = True
                break

        return result


class Group(BaseModel):
    gid: int
    members: list[Username] = Field(default_factory=list)


class UserDatabase(BaseModel):
    default_shell: str
    extrausers_root: str
    groups: dict[Groupname, Group]
    home_root: str
    shared_local: str | None = None
    """
    Location of the local symlink to shared_root e.g. shared will make $HOME/shared.
    this is a relative path
    """

    shared_root: str | None = None
    """Location of the NFS shared mount point e.g. /shared this is an absolute path."""

    restricted_access_hosts: list[str] = Field(default_factory=list)
    users: dict[Username, User]

    @model_validator(mode="after")
    def check_uids_unique(self) -> Self:
        taken_uids: set[int] = set()
        for udata in self.users.values():
            uid = udata.uid

            if uid in taken_uids:
                raise ValueError(f"UID {uid} is assigned multiple times")

            taken_uids.add(uid)

        return self


def load_db(db_name: str):
    import yaml
    with open(db_name) as dbf:
        yaml_text = dbf.read()

    return UserDatabase.model_validate(yaml.load(yaml_text, Loader=yaml.SafeLoader))


def save_db(db_name: str, db: UserDatabase):
    import yaml
    with open(db_name, "w") as dbf:
        dbf.write(yaml.dump(db.model_dump(), default_flow_style=False, indent=4))


def make_and_own(d: str, uid: int, gid: int, *, check_only: bool):
    if not exists(d):
        os.makedirs(d)
        if not check_only:
            os.chown(d, uid, gid)
    else:
        if not check_only:
            st = os.stat(d)
            if (st.st_uid, st.st_gid, st.st_mode & 0o777) == (0, 0, 0):
                # previously disabled, reenable
                os.chown(d, uid, gid)
                os.chmod(d, 0o755)
            else:
                if st.st_uid != uid:
                    raise ValueError(
                            f"{d} is owned by uid {st.st_uid}, should be {uid}")
                if st.st_gid != gid:
                    raise ValueError(
                            f"{d} is owned by gid {st.st_gid}, should be {gid}")


# {{{ update

def cmd_update(args):
    db = load_db(args.db)

    # check that access is specifically given to this host
    # ...unless the machine is not in the restricted list
    checkaccess = True
    thishost = socket.gethostname()
    if thishost not in db.restricted_access_hosts:
        checkaccess = False

    group_members: dict[str, list[str]] = {}
    gids: dict[Username, int] = {}

    passwd_lines: list[str] = []
    shadow_lines: list[str] = []

    for user, udata in db.users.items():
        home_dir = join(db.home_root, user)

        if not udata.is_active():
            if exists(home_dir):
                os.chown(home_dir, 0, 0)  # set ownership to root
                os.chmod(home_dir, 0o000)  # no access

            continue

        # check to see if user is has restricted access
        # ...otherwise move on to next user
        if checkaccess:
            if thishost not in udata.allowed_access_to_hosts:
                continue

        passwd_lines.append(":".join([
            user,
            "x",
            str(udata.uid),
            str(udata.gid),
            udata.name,
            home_dir,
            udata.shell or db.default_shell]))

        shadow_lines.append(":".join([
            user,
            udata.crypted_password or "x",
            "16289",
            "0",
            "99999",
            "7",
            "",
            "",
            ""]))

        for grp in udata.groups:
            group_members[grp] = [*group_members.get(grp, []), user]

        gids[user] = udata.gid

        ssh_dir = join(home_dir, ".ssh")

        make_and_own(home_dir, udata.uid, udata.gid, check_only=args.no_chown)
        make_and_own(ssh_dir, udata.uid, udata.gid, check_only=args.no_chown)

        keys_file = join(ssh_dir, "authorized_keys")

        with open(keys_file, "w") as keysf:
            keysf.write("# automatically generated by extrausers-maint\n")
            keysf.write("# WARNING! Do not edit--file will be overwritten.\n")
            keysf.write("\n")
            for k in udata.ssh_keys:
                keysf.write(k.strip() + "\n")

        if not args.no_chown:
            os.chown(keys_file, udata.uid, udata.gid)
            os.chmod(keys_file, 0o400)

        if args.with_shared:
            assert db.shared_root
            assert db.shared_local

            # this makes (for example)
            # /shared/username
            # and
            # /home/username/shared
            old_shared_root_dir = join(db.shared_root, user)
            shared_home_dir = join(db.shared_root, "home", user)
            shared_local_dir = join(home_dir, db.shared_local)

            if args.nfs_server:
                make_and_own(shared_home_dir,
                             udata.uid, udata.gid, check_only=args.no_chown)

            # migrate from old location
            if (os.path.islink(shared_local_dir)
                    and os.readlink(shared_local_dir) == old_shared_root_dir):
                os.unlink(shared_local_dir)

            # check for the symlink
            if not os.path.exists(shared_local_dir):
                # check if mounted...otherwise ignore
                if (os.path.ismount(os.path.abspath(db.shared_root))
                        or args.nfs_server):

                    try:
                        os.symlink(shared_home_dir, shared_local_dir)
                    except OSError:
                        print("your local shared cannot be made for %s" % user)

            if os.path.islink(shared_local_dir):
                os.lchown(shared_local_dir, udata.uid, udata.gid)

    for grp, gdata in db.groups.items():
        gids[grp] = gdata.gid
        group_members[grp] = (
            group_members.get(grp, [])
            + gdata.members)

    group_lines: list[str] = []

    for grp in gids:
        members = group_members.get(grp, [])
        gid = gids[grp]

        group_lines.append(":".join([
            grp,
            "x",
            str(gid),
            ",".join(members)]))

    with open(join(db.extrausers_root, "passwd"), "w") as outf:
        outf.write("\n".join(passwd_lines) + "\n")

    shadow_file = join(db.extrausers_root, "shadow")
    with open(shadow_file, "w") as outf:
        outf.write("\n".join(shadow_lines) + "\n")
    os.chmod(shadow_file, 0o600)

    with open(join(db.extrausers_root, "group"), "w") as outf:
        outf.write("\n".join(group_lines) + "\n")

# }}}


# {{{ change_password

def cmd_change_password(args):
    from base64 import b64encode
    from crypt import crypt
    salt = b64encode(os.urandom(16)).decode().replace("=", "")
    import getpass
    pw = getpass.getpass()
    pw_confirm = getpass.getpass()

    if pw != pw_confirm:
        raise RuntimeError("passwords do not match")

    salt_for_crypt = "$6$%s$" % salt
    crypted_password = crypt(pw, salt_for_crypt)

    db = load_db(args.db)
    db.users[args.user].crypted_password = crypted_password
    save_db(args.db, db)

# }}}


def find_taken_uids(db: UserDatabase):
    return {udata.uid for udata in db.users.values()}


def find_next_uid(db: UserDatabase):
    return max(find_taken_uids(db)) + 1


def cmd_find_next_uid(args):
    db = load_db(args.db)
    print("New UID:", find_next_uid(db))


def cmd_print_emails(args):
    db = load_db(args.db)
    for udata in db.users.values():
        if udata.is_active():
            print(udata.email, udata.name)


def main():
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--db", metavar="FILE", default="userdb.yml")
    subp = parser.add_subparsers()

    parser_update = subp.add_parser("update")
    parser_update.add_argument("--no-chown", action="store_true")
    parser_update.add_argument("--with-shared", action="store_true",
                               help="Set this to update a shared folder" +
                                    " in the user directory")
    parser_update.add_argument("--nfs-server", action="store_true",
                               help="Set this to update the shared folder" +
                                    " on the nfs server")
    parser_update.set_defaults(func=cmd_update)

    parser_passwd = subp.add_parser("passwd")
    parser_passwd.add_argument("user")
    parser_passwd.set_defaults(func=cmd_change_password)

    parser_next_uid = subp.add_parser("next-uid")
    parser_next_uid.set_defaults(func=cmd_find_next_uid)

    parser_next_uid = subp.add_parser("emails")
    parser_next_uid.set_defaults(func=cmd_print_emails)

    args = parser.parse_args()

    if not hasattr(args, "func"):
        parser.print_help()
        sys.exit(1)

    args.func(args)


if __name__ == "__main__":
    main()

# vim: foldmethod=marker
